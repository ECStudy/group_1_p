import * as vscode from "vscode";

import { Tree } from "../node/Tree";

import { Group } from "../node/Group";
import { Tab } from "../node/Tab";
import {
    CREATE_TYPE,
    ICreateGroup,
    IUpdateGroup,
    IUpdateTab,
} from "../type/group";
import { EventHandler } from "../EventHandler";
import { Node } from "../node/Node";
import { UpdateAction } from "../type/enums";
import { v4 as uuidv4 } from "uuid";
import { Serialize } from "../Serialize";
import { TreeItemType } from "../type/types";
import { STORAGE_KEYS, StoreageManager } from "../StorageManager";

export class TreeDataProvider
    implements
        vscode.TreeDataProvider<vscode.TreeItem>,
        vscode.TreeDragAndDropController<Group | Tab>
{
    private tree: Tree;
    private storageManager: StoreageManager;

    // EventEmitterÎ•º Ï†ïÏùò
    private _onDidChangeTreeData: vscode.EventEmitter<
        vscode.TreeItem | undefined | void
    > = new vscode.EventEmitter<vscode.TreeItem | undefined | void>();

    readonly onDidChangeTreeData: vscode.Event<
        vscode.TreeItem | undefined | void
    > = this._onDidChangeTreeData.event;

    readonly dropMimeTypes: string[] = ["application/vnd.code.tree.tab"];
    readonly dragMimeTypes: string[] = ["application/vnd.code.tree.tab"];

    private context: vscode.ExtensionContext;

    private viewCollapse: boolean;
    private viewDescription: boolean;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.tree = new Tree("root");
        this.viewCollapse = false;
        this.viewDescription = true;
        //
        //this.tree.addEvent("create", () => this.triggerEventRerender());
        //this.tree.addEvent("delete", () => this.triggerEventRerender());
        //this.tree.addEvent("update", () => this.triggerEventRerender());
        this.storageManager = new StoreageManager(this.context);

        this.loadData();
    }

    public getGlobalState<T>(key: STORAGE_KEYS) {
        return this.storageManager.get<T>(key);
    }

    public saveData() {
        const tree = this.tree.getTree();
        const serializedTree = Serialize.toJson(tree);

        this.storageManager.set(STORAGE_KEYS.TREE_DATA, serializedTree);
        this.storageManager.set(STORAGE_KEYS.VIEW_COLLAPSE, this.viewCollapse);
        this.storageManager.set(
            STORAGE_KEYS.VIEW_DESCRIPTION,
            this.viewDescription
        );
    }

    private loadData() {
        const jsonTreeData = this.getGlobalState<string>(
            STORAGE_KEYS.TREE_DATA
        );

        if (jsonTreeData) {
            const treeClass = Serialize.fromJson(jsonTreeData);

            console.log("üéà json Î≥µÍµ¨", treeClass);

            this.tree.setChildren(treeClass.getChildren());
        }

        const viewCollapse = this.getGlobalState<boolean>(
            STORAGE_KEYS.VIEW_COLLAPSE
        );
        if (viewCollapse !== undefined) {
            this.viewCollapse = viewCollapse;
        }
    }

    public async restoreData(jsonTreeData: string, target?: Group) {
        if (jsonTreeData) {
            const treeClass = Serialize.fromJson(jsonTreeData);

            if (!target) {
                this.tree.setChildren(treeClass.getChildren());
            } else {
                target.setChildren(treeClass.getChildren());
            }

            this.triggerEventRerender();
        }
    }

    public triggerEventRerender() {
        this.saveData();
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: Group | Tab): vscode.TreeItem {
        const itemPayload = {
            viewDescription: this.viewDescription,
        };
        const treeItem = element.render(this.context, itemPayload);
        if (element.type === TreeItemType.Group) {
            //Ï†ëÍ∏∞ ÌéºÏπòÍ∏∞ Ï∫êÏã± ÎïåÎ¨∏Ïóê Î†åÎçî Ìï† Îïå ÏïÑÏù¥Îîî Î≥ÄÍ≤Ω
            treeItem.id = `${element.id}_${
                element.collapsed ? "collapsed" : "expanded"
            }`;

            treeItem.collapsibleState = element.collapsed
                ? vscode.TreeItemCollapsibleState.Collapsed //Îã´Ìûò 1
                : vscode.TreeItemCollapsibleState.Expanded; //Ïó¥Î¶º 2
        }

        return treeItem;
    }

    getChildren(element?: Group | Tab): Group[] {
        if (element instanceof Tab) {
            return [];
        }

        const target = element ?? this.tree;
        return target.getChildren();
    }

    getGroups() {
        return this.tree.getAllGroups();
    }

    getAllParent() {
        const parent = this.tree.getAllGroups();
        //ÎìúÎûòÍ∑∏Ïï§ ÎìúÎûçÏù¥ Í∞ÄÎä•Ìïú Î∂ÄÎ™®Î•º ÏúÑÌï¥ÏÑú tree Ï∂îÍ∞Ä
        parent.push(this.tree);
        return parent;
    }

    getGroupById(parentList: Node[], id: string): Node | undefined {
        // parentList Î∞∞Ïó¥ÏùÑ ÏàúÌöåÌïòÎ©∞ ÌÉêÏÉâ
        for (const parent of parentList) {
            // ÌòÑÏû¨ ÎÖ∏ÎìúÏùò idÏôÄ ÎπÑÍµê
            if (parent.id === id) {
                return parent;
            }

            // ÏûêÏãù ÎÖ∏Îìú Ïû¨Í∑Ä ÌÉêÏÉâ
            const result = this.getGroupById(parent.getChildren(), id);
            if (result) {
                return result; // Î∞úÍ≤¨ Ïãú Ï¶âÏãú Î∞òÌôò
            }
        }

        // Î∞∞Ïó¥ Ï†ÑÏ≤¥Î•º ÌÉêÏÉâÌï¥ÎèÑ Í≤∞Í≥ºÎ•º Ï∞æÏßÄ Î™ªÌïòÎ©¥ undefined Î∞òÌôò
        return undefined;
    }

    /**
     * Í∑∏Î£π ÏÉùÏÑ±
     */
    createGroup = async (payload: ICreateGroup) => {
        //Í∑∏Î£π Ïã†Í∑ú ÏÉùÏÑ±
        if (payload.type === CREATE_TYPE.NEW) {
            //Í∑∏Î£π ÏÉùÏÑ±
            if (payload?.label) {
                const group = new Group(`group_${uuidv4()}`, payload?.label);
                this.tree.add(group);

                //ÌÉ≠ ÏûàÎäî Í≤ΩÏö∞ ÌÉ≠ ÏÉùÏÑ±
                if (payload?.uris) {
                    payload?.uris.forEach(async (uri) => {
                        const stat = await vscode.workspace.fs.stat(uri);
                        //Îã§Ï§ë ÏÑ†ÌÉùÌï¥ÎèÑ ÌååÏùºÎßå Tab ÏÉùÏÑ±
                        if (stat.type === vscode.FileType.File) {
                            const nativeTab: vscode.Tab = {
                                input: { uri },
                                label: uri.path.split("/").pop() || "Unknown",
                            } as vscode.Tab;

                            const tab = new Tab(`tab_${uuidv4()}`, nativeTab);
                            group.add(tab);
                            //TODO : group Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏàòÏ†ï
                            (group as any)?.setUpdateCollapsed(false);
                        }
                    });
                }
            }
        }

        //Í∑∏Î£πÏù¥ Ïù¥ÎØ∏ ÏûàÎäî Í≤ΩÏö∞
        else if (payload.type === CREATE_TYPE.PREV) {
            if (payload?.group && payload?.uris) {
                payload?.uris.forEach(async (uri) => {
                    const stat = await vscode.workspace.fs.stat(uri);
                    //Îã§Ï§ë ÏÑ†ÌÉùÌï¥ÎèÑ ÌååÏùºÎßå Tab ÏÉùÏÑ±
                    if (stat.type === vscode.FileType.File) {
                        const nativeTab: vscode.Tab = {
                            input: { uri },
                            label: uri.path.split("/").pop() || "Unknown",
                        } as vscode.Tab;

                        const tab = new Tab(`tab_${uuidv4()}`, nativeTab);
                        payload?.group?.add(tab);
                        //TODO : group Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÏàòÏ†ï
                        (payload.group as any)?.setUpdateCollapsed(false);
                    }
                });
            }
        }

        this.triggerEventRerender();
    };

    createGroupAndGroup(payload: ICreateGroup) {
        //Í∑∏Î£πÏóêÏÑú Í∑∏Î£π ÏÉùÏÑ±
        if (payload?.label) {
            const group = new Group(`group_${uuidv4()}`, payload?.label);
            payload?.group?.add(group);
        }

        this.triggerEventRerender();
    }

    resetAll() {
        const children = [...this.tree.getChildren()];
        this.tree.reset();
        this.triggerEventRerender();
        return children;
    }

    remove(node: Node) {
        node.remove(node);
        this.triggerEventRerender();
    }

    updateGroup(payload: IUpdateGroup) {
        switch (payload.action) {
            case UpdateAction.LABEL:
                payload?.label && payload.group.setLabel(payload?.label);
                break;
            case UpdateAction.COLOR:
                payload?.color && payload.group.setColor(payload?.color);
                break;
            case UpdateAction.DESCRIPTION:
                payload?.description &&
                    payload.group.setDescription(payload?.description);
                break;
            default:
                break;
        }
        this.triggerEventRerender();
    }

    updateTab(payload: IUpdateTab) {
        switch (payload.action) {
            case UpdateAction.LABEL:
                payload?.label && payload.tab.setLabel(payload?.label);
                break;
            case UpdateAction.DESCRIPTION:
                payload?.description &&
                    payload.tab.setDescription(payload?.description);
                break;
            default:
                break;
        }
        this.triggerEventRerender();
    }

    setCollapsed(node: any, isCollapse: boolean) {
        // Ï†ÑÏ≤¥ Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        this.viewCollapse = isCollapse;

        // Í∞Å Í∑∏Î£πÏùò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        node.forEach((group: Group) => {
            group.setCollapsed(isCollapse);
        });

        this.triggerEventRerender();
    }

    moveNode(target: any, dropNodeArr: any[]) {
        if (!dropNodeArr) {
            return;
        }

        let targetGroup: Tree | Group;
        if (!target) {
            targetGroup = this.tree;
        } else {
            if (target?.type === TreeItemType.Group) {
                targetGroup = target;
            }
            //ÎìúÎûçÌïú ÌÉÄÍ≤üÏù¥ Tab
            else if (target?.type === TreeItemType.Tab) {
                targetGroup = target.getParentNode() as Group;
            } else {
                //
            }
        }

        const allGroups = this.getAllParent();
        const nodes = dropNodeArr
            .map((node: any) => {
                const tempNode = this.tree.findPath(
                    node.split("/").filter(Boolean)
                );
                // const parentNode = this.getGroupById(
                //     allGroups,
                //     node.payload.parentNodeId
                // );

                // if (parentNode) {
                //     tempNode.setParentNode(parentNode);
                // }

                return tempNode;
            })
            .filter((node: any) => node);

        //Í∏∞Ï°¥ Î∂ÄÎ™® children Î™©Î°ùÏóêÏÑú ÎåÄÏÉÅ node ÏßÄÏõåÏ§òÏïºÌï®
        // nodes.forEach((node) => {
        //     const parent = node.getParentNode();
        //     const parentChildren = parent?.getChildren();
        //     const filteredParentChildren = parentChildren?.filter(
        //         (parentChildrenNode) => parentChildrenNode.id !== node.id
        //     );

        //     parent?.setChildren(filteredParentChildren);
        // });

        nodes.forEach((node) => {
            //ÏûêÍ∏∞ ÏûêÏã†Ïù¥ ÏûêÍ∏∞ ÏûêÏã† Í∑∏Î£πÏù∏ Í≤ΩÏö∞ ÎÑ£ÏùÑ Ïàò ÏóÜÎã§.
            if (node.id === targetGroup.id) {
                return;
            }

            //nodeÍ∞Ä tabÏù∏Îç∞ treeÏóê ÎÑ£ÏùÑ ÏàòÎäî ÏóÜÎã§.
            if (
                node.type === TreeItemType.Tab &&
                targetGroup.type === TreeItemType.Tree
            ) {
                return;
            }

            targetGroup.add(node);
        });

        this.triggerEventRerender();
    }

    getTree() {
        return this.tree;
    }

    setViewDescription(isViewDescription: boolean) {
        this.viewDescription = isViewDescription;
        this.triggerEventRerender();
    }
}
